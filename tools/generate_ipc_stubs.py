# On a build this script is automatically run, generating build/generated/ipc_stubs.h, which contains:
# - MessageType enum
# - getEnumType(MessageType) helper
# - toString(MessageType) helper
# - IIPCMessageHandler interface


# fmt: off
import os
import sys


# Define the struct names that will be used to generate build/generated/ipc_stubs.h
IPC_STRUCT_NAMES = [
    "SomeData",  # Example struct. Remove this once we have real structs.
]


def generate_ipc_stubs(output_dir, struct_names):
    output_path = os.path.join(output_dir, "generated")
    print(f"Generating ipc stubs...\nOutput path: {output_path}")

    os.makedirs(output_path, exist_ok=True)

    ipc_stub_file = os.path.join(output_path, "ipc_stubs.h")
    with open(ipc_stub_file, "w") as f:
        f.write("// This file is auto-generated by tools/generate_ipc_stubs.py\n")
        f.write("// Do not modify this file directly.\n\n")
        f.write("#pragma once\n\n")
        f.write("#include <cstdint>\n")
        f.write("#include <type_traits>\n\n")
        f.write("#include \"ipc.h\"\n\n")
        f.write("#include \"logging.h\"\n\n")
        f.write("namespace ipc\n{\n\n")

        generate_message_type_enum(f, struct_names)
        generate_forward_declarations(f, struct_names)
        generate_struct_completion_traits(f)
        generate_get_enum_type_function(f, struct_names)
        generate_enum_to_string_function(f, struct_names)
        generate_message_handler_interface(f, struct_names)

        f.write("} // namespace ipc\n")


def generate_message_type_enum(file, struct_names):
    max_name_length = max(len(name) for name in struct_names)

    file.write("enum class MessageType : uint8_t\n{\n")

    for idx, name in enumerate(struct_names):
        file.write(f"    {name.ljust(max_name_length)} = {idx},\n")

    file.write("};\n\n")


def generate_forward_declarations(file, struct_names):
    file.write("// You must remember to implement each of these structs.\n\n")

    for name in struct_names:
        file.write(f"struct {name};\n")

    file.write("\n")


def generate_struct_completion_traits(file):
    file.write("template<typename T, typename = void>\n")
    file.write("struct is_struct_complete : std::false_type {};\n\n")

    file.write("template<typename T>\n")
    file.write("struct is_struct_complete<T, std::void_t<decltype(sizeof(T))>> : std::true_type {};\n\n")


def generate_get_enum_type_function(file, struct_names):
    file.write("template<typename T>\n")
    file.write("auto getEnumType() -> MessageType\n")
    file.write("{\n")
    file.write("    static_assert(false, \"You should never reach this point.\");\n")
    file.write("}\n\n")

    for name in struct_names:
        file.write(f"template<>\n")
        file.write(f"auto getEnumType<{name}>() -> MessageType\n")
        file.write("{\n")
        file.write(f"    static_assert(is_struct_complete<{name}>::value, \"You must fully define this struct in common/ipc_structs.h.\");\n")
        file.write(f"    return MessageType::{name};\n")
        file.write("}\n\n")


def generate_enum_to_string_function(file, struct_names):
    file.write("auto toString(MessageType type) -> std::string\n")
    file.write("{\n")
    file.write("    switch (type)\n")
    file.write("    {\n")

    for name in struct_names:
        file.write(f"        case MessageType::{name}:\n")
        file.write(f"            return \"{name}\";\n")

    file.write("        default:\n")
    file.write("            return \"Unknown\";\n")
    file.write("    }\n")
    file.write("}\n\n")


def generate_message_handler_interface(file, struct_names):
    file.write("template<typename T>\n")
    file.write("auto fromBytes(const std::vector<uint8_t>& message) -> std::optional<T>;\n\n")
    file.write("class IIPCMessageHandler\n")
    file.write("{\n")
    file.write("public:\n")
    file.write("    virtual ~IIPCMessageHandler() = default;\n\n")

    file.write("    void handleMessage(const std::vector<uint8_t>& message)\n")
    file.write("    {\n")
    file.write("        const auto messageType = static_cast<MessageType>(message[0]);\n")
    file.write("        switch (messageType)\n")
    file.write("        {\n")

    for name in struct_names:
        file.write(f"            case MessageType::{name}:\n")
        file.write("            {\n")
        file.write(f"                const auto object = ipc::fromBytes<{name}>(message);\n")
        file.write("                if (!object.has_value())\n")
        file.write("                {\n")
        file.write(f"                    ShowError(\"Failed to deserialize {name} message.\");\n")
        file.write("                    break;\n")
        file.write("                }\n")
        file.write(f"                handleMessage_{name}(*object);\n")
        file.write("            }\n")
        file.write(f"            break;\n")

    file.write("            default:\n")
    file.write("                break;\n")
    file.write("        }\n")
    file.write("    }\n\n")
    file.write("protected:\n")

    for name in struct_names:
        file.write(f"    virtual void handleMessage_{name}(const {name}& message) = 0;\n")

    file.write("};\n\n")


if __name__ == "__main__":
    current_path = os.path.dirname(os.path.realpath(__file__))
    output_directory = os.path.join(current_path, sys.argv[1])

    generate_ipc_stubs(output_directory, IPC_STRUCT_NAMES)
